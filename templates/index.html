<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Whack-an-Error - Surface Code</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Press Start 2P", "VT323", "Courier New", monospace;
      background: #050917;
      color: #f7faff;
      --cell-min-size: 48px;
      --cell-min-height: 48px;
      --cell-gap: 8px;
      --stabilizer-size: 36px;
      --qubit-font-size: 0.85rem;
      --pixel-border: 4px;
      --pixel-radius: 0;
      --pixel-shadow: 6px 6px 0 #020410;
      --pixel-shadow-strong: 10px 10px 0 #020410;
      --panel-bg: #0f1836;
      --panel-border: #56f2ff;
      --panel-shadow: 8px 8px 0 #020410;
      --accent-primary: #54f5ff;
      --accent-primary-dark: #009db3;
      --accent-secondary: #ff66c4;
      --accent-secondary-dark: #c8529c;
      --accent-ghost: #101b3f;
      --text-soft: rgba(247, 250, 255, 0.7);
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 32px;
      background:
        repeating-linear-gradient(0deg, rgba(13, 20, 48, 0.75) 0 24px, rgba(7, 11, 28, 0.75) 24px 48px),
        repeating-linear-gradient(90deg, rgba(22, 34, 72, 0.4) 0 24px, rgba(10, 16, 40, 0.4) 24px 48px),
        radial-gradient(circle at 12% 18%, rgba(84, 245, 255, 0.22), transparent 50%),
        radial-gradient(circle at 82% 12%, rgba(255, 102, 196, 0.2), transparent 50%),
        linear-gradient(135deg, #050917, #090f29 70%, #030612 100%);
      font-family: inherit;
      font-size: 0.78rem;
      letter-spacing: 0.04em;
      line-height: 1.6;
      image-rendering: pixelated;
      text-transform: none;
    }
    .app-shell {
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(520px, 1fr);
      gap: 32px;
      width: min(1120px, 100%);
    }
    .panel {
      background: var(--panel-bg);
      border: var(--pixel-border) solid var(--panel-border);
      border-radius: var(--pixel-radius);
      padding: 26px;
      box-shadow: var(--panel-shadow);
      image-rendering: pixelated;
      box-sizing: border-box;
      width: 100%;
    }
    h1 {
      margin: 0 0 16px;
      font-size: 1.15rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #fffefc;
      text-shadow: 4px 4px 0 #020410;
    }
    h2 {
      margin: 0 0 12px;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #f7faff;
      text-shadow: 3px 3px 0 #020410;
    }
    p.subtitle {
      margin: 0 0 24px;
      color: var(--text-soft);
      font-size: 0.7rem;
      line-height: 1.6;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 400;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .form-field {
      margin-bottom: 18px;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 400;
      cursor: pointer;
    }
    .toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent-primary);
    }
    .toggle span {
      font-size: 0.72rem;
    }
    .toggle-hint {
      margin: 6px 0 0;
      color: var(--text-soft);
      font-size: 0.65rem;
      line-height: 1.5;
    }
    select,
    input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: var(--pixel-radius);
      border: var(--pixel-border) solid rgba(121, 202, 255, 0.6);
      background: rgba(6, 12, 34, 0.9);
      color: inherit;
      font-size: 0.72rem;
      box-sizing: border-box;
      box-shadow: inset 4px 4px 0 rgba(10, 17, 44, 0.7);
    }
    body:not(.expert-mode) .expert-only {
      display: none !important;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin: 24px 0 12px;
    }
    button {
      border: var(--pixel-border) solid #101527;
      border-radius: var(--pixel-radius);
      padding: 12px 16px;
      font-weight: 400;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 160ms steps(4, end), box-shadow 160ms steps(4, end);
      box-shadow: 4px 4px 0 #020410;
      min-width: 0;
    }
    button.primary {
      background: linear-gradient(180deg, var(--accent-primary) 0%, var(--accent-primary-dark) 100%);
      border-color: #0a1a2f;
      color: #020410;
      flex: 1 1 160px;
    }
    button.secondary {
      background: linear-gradient(180deg, var(--accent-secondary) 0%, var(--accent-secondary-dark) 100%);
      border-color: #2c0d27;
      color: #04030d;
      flex: 1 1 160px;
    }
    button.ghost {
      background: var(--accent-ghost);
      border-color: #24335d;
      color: #f7faff;
      flex: 1 1 140px;
    }
    button.ghost.is-off {
      background: #0a1129;
      border-color: #1c2647;
      opacity: 0.75;
    }
    .stats-overlay-content {
      display: grid;
      gap: 18px;
      width: 100%;
      max-width: 100%;
    }
    #stats-overlay-output {
      flex: 1 1 auto;
      overflow: auto;
      padding-right: 6px;
      min-height: 0;
      max-height: 100%;
      width: 100%;
      box-sizing: border-box;
    }
    .stats-section {
      padding: 16px;
      border-radius: var(--pixel-radius);
      background: rgba(12, 18, 44, 0.92);
      border: var(--pixel-border) solid rgba(121, 202, 255, 0.65);
      box-shadow: 6px 6px 0 #020410;
      box-sizing: border-box;
      max-width: 100%;
    }
    .stats-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 14px;
      margin: 0 0 12px;
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .stats-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: var(--pixel-radius);
      border: 1px solid rgba(120, 160, 255, 0.25);
      background: rgba(6, 10, 34, 0.75);
      box-shadow: 3px 3px 0 rgba(2, 4, 16, 0.5);
    }
    .stats-legend-swatch {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid rgba(255, 255, 255, 0.6);
    }
    .stats-table-wrapper {
      overflow-x: auto;
      margin-bottom: 12px;
      max-width: 100%;
    }
    .stats-section h3 {
      margin: 0 0 12px;
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .stats-chart {
      width: 100%;
      max-width: min(560px, 100%);
      height: 280px;
      display: block;
      border-radius: var(--pixel-radius);
      background: rgba(6, 10, 34, 0.75);
      border: var(--pixel-border) solid rgba(86, 135, 255, 0.4);
      margin-bottom: 12px;
      box-shadow: 4px 4px 0 #020410;
    }
    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      min-width: 480px;
    }
    .stats-table thead {
      background: rgba(12, 20, 48, 0.95);
    }
    .stats-table th,
    .stats-table td {
      padding: 8px 10px;
      border: 1px solid rgba(120, 160, 255, 0.22);
      text-align: left;
      background: rgba(6, 10, 34, 0.75);
    }
    .stats-table tbody tr:nth-child(odd) {
      background: rgba(8, 14, 36, 0.85);
    }
    .stats-summary-list {
      margin: 12px 0 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .stats-summary-list strong {
      color: #b7caff;
    }
    button:disabled {
      opacity: 0.5;
      cursor: wait;
      transform: none;
      box-shadow: 4px 4px 0 rgba(2, 4, 16, 0.4);
    }
    button:not(:disabled):hover {
      transform: translate(-3px, -3px);
      box-shadow: 6px 6px 0 #01030b;
    }
    button:not(:disabled):active {
      transform: translate(0, 0);
      box-shadow: inset 4px 4px 0 rgba(8, 16, 32, 0.85);
    }
    .button-progress {
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }
    .button-progress::before {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(2, 8, 20, 0.4);
      transform-origin: left center;
      transform: scaleX(var(--progress, 0));
      transition: transform 0.1s linear;
      z-index: -1;
    }
    .button-progress.active::before {
      animation: buttonFill var(--auto-duration, 1000ms) linear forwards;
    }
    @keyframes buttonFill {
      from {
        transform: scaleX(0);
      }
      to {
        transform: scaleX(1);
      }
    }
    .meta-label {
      margin-top: 12px;
      font-size: 0.65rem;
      color: var(--text-soft);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .stats {
      margin-top: 24px;
      display: grid;
      gap: 10px;
    }
    .stats div {
      background: rgba(12, 18, 44, 0.9);
      border-radius: var(--pixel-radius);
      padding: 12px 14px;
      border: var(--pixel-border) solid rgba(114, 182, 255, 0.4);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      box-shadow: 4px 4px 0 #020410;
    }
    .log {
      margin-top: 24px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 6px;
      border: var(--pixel-border) solid rgba(114, 182, 255, 0.3);
      background: rgba(8, 13, 34, 0.85);
      box-shadow: 6px 6px 0 #020410;
      border-radius: var(--pixel-radius);
    }
    .log h2 {
      margin-top: 0;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .log ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
      font-size: 0.68rem;
    }
    .log li {
      padding: 10px 12px;
      border-radius: var(--pixel-radius);
      background: rgba(13, 20, 52, 0.8);
      border: 1px solid rgba(90, 126, 240, 0.28);
      box-shadow: inset 4px 4px 0 rgba(4, 8, 20, 0.7);
    }
    .game-surface {
      display: grid;
      gap: 24px;
    }
    .board-wrapper {
      background: rgba(9, 15, 36, 0.95);
      border-radius: var(--pixel-radius);
      padding: 28px;
      border: var(--pixel-border) solid rgba(114, 182, 255, 0.5);
      box-shadow: var(--pixel-shadow-strong);
      scroll-margin-top: 18px;
      overflow: hidden;
    }
    .board-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 18px;
      flex-wrap: wrap;
      gap: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .board {
      display: grid;
      gap: var(--cell-gap);
      --board-size: 1;
      --board-scale: 1;
      grid-template-columns: repeat(var(--board-size), minmax(calc(var(--cell-min-size) * var(--board-scale, 1)), 1fr));
      justify-items: stretch;
      background:
        repeating-linear-gradient(0deg, rgba(18, 32, 72, 0.35) 0 2px, transparent 2px 48px),
        repeating-linear-gradient(90deg, rgba(18, 32, 72, 0.35) 0 2px, transparent 2px 48px);
      padding: 12px;
      border: var(--pixel-border) solid rgba(76, 120, 232, 0.4);
      border-radius: var(--pixel-radius);
      box-shadow: inset 6px 6px 0 rgba(6, 10, 28, 0.7);
      max-width: min(100%, min(80vh, 560px));
      width: min(100%, min(80vh, 560px));
      height: auto;
      aspect-ratio: 1 / 1;
      box-sizing: border-box;
      margin: 0 auto;
    }
    .cell {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: calc(var(--cell-min-height) * var(--board-scale, 1));
      background: rgba(8, 14, 36, 0.7);
      border: 1px solid rgba(60, 92, 180, 0.35);
      box-shadow: inset 4px 4px 0 rgba(4, 8, 20, 0.6);
    }
    .cell.placeholder {
      color: rgba(220, 224, 255, 0.8);
      font-size: 0.75rem;
      padding: 16px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .cell::after {
      display: none;
    }
    .cell.empty::after {
      display: none;
    }
    .qubit {
      position: relative;
      z-index: 2;
      width: 100%;
      height: 100%;
      border-radius: var(--pixel-radius);
      border: var(--pixel-border) solid rgba(102, 162, 255, 0.65);
      background: linear-gradient(180deg, rgba(120, 182, 255, 0.95) 0%, rgba(64, 108, 232, 0.95) 100%);
      color: #061238;
      font-weight: 400;
      font-size: calc(var(--qubit-font-size) * var(--board-scale, 1));
      cursor: pointer;
      transition: transform 120ms steps(5, end), border 120ms steps(5, end), box-shadow 120ms steps(5, end);
      box-shadow: inset 4px 4px 0 rgba(255, 255, 255, 0.18);
    }
    .qubit:hover:not(:disabled) {
      transform: translate(-2px, -2px);
      box-shadow: 6px 6px 0 #020410, inset 4px 4px 0 rgba(255, 255, 255, 0.18);
    }
    .qubit.has-error {
      border-color: rgba(255, 118, 158, 0.9);
      background: linear-gradient(180deg, rgba(255, 132, 172, 0.95) 0%, rgba(210, 64, 148, 0.95) 100%);
      color: #2b0618;
      box-shadow: inset 4px 4px 0 rgba(255, 210, 230, 0.26);
    }
    .qubit.corrected {
      box-shadow: inset 4px 4px 0 rgba(115, 255, 202, 0.9);
      border-color: rgba(115, 255, 202, 0.8);
    }
    .qubit.residual {
      border-color: rgba(255, 196, 99, 0.9);
      background: linear-gradient(180deg, rgba(255, 213, 116, 0.95) 0%, rgba(214, 144, 48, 0.95) 100%);
      color: #291601;
      box-shadow: inset 4px 4px 0 rgba(255, 240, 200, 0.24);
    }
    .qubit:disabled {
      cursor: default;
      opacity: 0.55;
      box-shadow: inset 4px 4px 0 rgba(12, 20, 44, 0.8);
    }
    .stabilizer {
      position: relative;
      z-index: 1;
      width: calc(var(--stabilizer-size) * var(--board-scale, 1));
      height: calc(var(--stabilizer-size) * var(--board-scale, 1));
      border-radius: var(--pixel-radius);
      background: rgba(68, 102, 220, 0.65);
      border: var(--pixel-border) solid rgba(112, 164, 255, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(0.65rem * var(--board-scale, 1));
      font-weight: 400;
      color: #020610;
      text-transform: uppercase;
      transition: transform 160ms steps(6, end), background 160ms steps(6, end), border 160ms steps(6, end);
      box-shadow: inset 3px 3px 0 rgba(7, 12, 32, 0.7);
    }
    .stabilizer.active {
      background: rgba(255, 136, 182, 0.95);
      border-color: rgba(255, 189, 220, 0.9);
      color: #320917;
      transform: translate(-2px, -2px);
      box-shadow: 6px 6px 0 #020410;
    }
    @media (max-width: 960px) {
      body {
        padding: 24px 20px;
      }
      .app-shell {
        grid-template-columns: 1fr;
        gap: 24px;
      }
    }
    @media (max-width: 720px) {
      :root {
        --cell-min-size: 36px;
        --cell-min-height: 36px;
        --cell-gap: 8px;
        --stabilizer-size: 30px;
        --qubit-font-size: 0.82rem;
      }
      body {
        padding: 24px 16px;
      }
      .panel {
        padding: 22px;
      }
      .board-wrapper {
        padding: 20px;
      }
      .log {
        max-height: 200px;
      }
      .actions {
        gap: 12px;
      }
      .actions button {
        flex: 1 1 100%;
      }
      .stats-table {
        min-width: 360px;
      }
    }
    @media (max-width: 540px) {
      :root {
        --cell-min-size: 28px;
        --cell-min-height: 28px;
        --cell-gap: 4px;
        --stabilizer-size: 24px;
        --qubit-font-size: 0.72rem;
      }
      .board-wrapper {
        padding: 16px;
      }
      .actions {
        gap: 10px;
      }
      .log {
        max-height: 180px;
      }
      button {
        font-size: 0.68rem;
        padding: 10px 14px;
      }
      .panel {
        padding: 18px;
      }
      .stats-section {
        padding: 14px;
      }
      .stats-table {
        min-width: 320px;
      }
    }
    @media (max-width: 420px) {
      :root {
        --cell-min-size: 20px;
        --cell-min-height: 20px;
        --cell-gap: 2px;
        --stabilizer-size: 18px;
        --qubit-font-size: 0.62rem;
      }
      body {
        padding: 14px;
      }
      .panel {
        padding: 16px;
      }
      .board-wrapper {
        padding: 14px;
      }
      .stats-table {
        min-width: 280px;
      }
      h1 {
        font-size: 1rem;
      }
      h2 {
        font-size: 0.8rem;
      }
      p.subtitle {
        font-size: 0.64rem;
      }
    }
    .status-line {
      margin: 6px 0 0;
      min-height: 1.4em;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #d9e6ff;
    }
    .status-line.error {
      color: #ff8094;
    }
    .summary-card {
      margin-top: 18px;
      padding: 20px;
      border-radius: var(--pixel-radius);
      background: rgba(10, 16, 40, 0.92);
      border: var(--pixel-border) solid rgba(114, 182, 255, 0.45);
      box-shadow: 6px 6px 0 #020410;
      display: none;
      max-width: 100%;
      box-sizing: border-box;
    }
    .summary-card.visible {
      display: block;
    }
    .summary-card pre {
      margin-top: 12px;
      max-height: 220px;
      overflow: auto;
      background: rgba(6, 10, 34, 0.72);
      padding: 16px;
      border-radius: var(--pixel-radius);
      border: 1px solid rgba(86, 128, 240, 0.28);
      font-size: 0.68rem;
      letter-spacing: 0.04em;
      box-sizing: border-box;
      overflow-wrap: anywhere;
      word-break: break-word;
      white-space: pre-wrap;
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(4, 8, 20, 0.92);
      z-index: 20;
      padding: 24px;
    }
    .overlay.visible {
      display: flex;
    }
    .overlay-card {
      background: rgba(10, 18, 44, 0.96);
      padding: 28px;
      border-radius: var(--pixel-radius);
      width: min(720px, calc(100% - 24px));
      max-height: 82vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: var(--pixel-border) solid rgba(118, 190, 255, 0.45);
      position: relative;
      box-shadow: var(--pixel-shadow-strong);
    }
    .overlay-card pre {
      background: rgba(12, 16, 40, 0.88);
      padding: 16px;
      border-radius: var(--pixel-radius);
      border: 1px solid rgba(102, 148, 248, 0.26);
      max-height: 60vh;
      overflow: auto;
      font-size: 0.66rem;
      letter-spacing: 0.04em;
    }
    .overlay-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      border-radius: var(--pixel-radius);
      border: var(--pixel-border) solid rgba(118, 190, 255, 0.5);
      background: rgba(5, 12, 36, 0.9);
      color: #f7faff;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding: 0;
      cursor: pointer;
      box-shadow: 4px 4px 0 #020410;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <aside class="panel">
      <h1>Whack-an-Error</h1>
      <p class="subtitle">Explore surface-code error correction. Flip qubits to clear the syndrome without inducing a logical error.</p>

      <div class="form-field">
        <label class="toggle" for="expert-toggle">
          <input type="checkbox" id="expert-toggle" />
          <span>Expert mode</span>
        </label>
        <p class="toggle-hint">Reveal advanced controls and diagnostics.</p>
      </div>

      <div class="form-field expert-only">
        <label for="player-name">Your name</label>
        <input id="player-name" type="text" placeholder="Optional" maxlength="100" data-expert-control="true" />
      </div>

      <div class="form-field">
        <label for="config-d">Code distance (d)</label>
        <select id="config-d" aria-label="Select code distance">
          {% for value in grid_sizes %}
          <option value="{{ value }}">d = {{ value }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="form-field expert-only">
        <label for="config-levels">Levels per run</label>
        <select id="config-levels" aria-label="Select number of levels" data-expert-control="true">
          {% for value in allowed_level_counts %}
          <option value="{{ value }}" {% if value == level_count %}selected{% endif %}>{{ value }} levels</option>
          {% endfor %}
        </select>
      </div>

      <div class="actions">
        <button type="button" class="primary" id="start-game">Start Game</button>
        <button type="button" class="secondary" id="show-stats">Show Stats</button>
        <button type="button" class="secondary expert-only" id="show-data">Show Raw Data</button>
        <button type="button" class="ghost" id="reset-game">Reset</button>
      </div>

      <div class="form-field expert-only">
        <label for="config-rounds">Rounds per level</label>
        <select id="config-rounds" aria-label="Select rounds per level" data-expert-control="true">
          {% for value in allowed_rounds %}
          <option value="{{ value }}" {% if value == rounds_per_level %}selected{% endif %}>{{ value }} rounds</option>
          {% endfor %}
        </select>
      </div>

      <p class="meta-label">Database: {{ database_mode }}</p>

      <div class="stats">
        <div><strong>Level:</strong> <span id="stat-level">-</span></div>
        <div><strong>Rounds:</strong> <span id="stat-round">-</span></div>
        <div><strong>Logical errors:</strong> <span id="stat-logical">-</span></div>
        <div><strong>Empty syndrome rounds:</strong> <span id="stat-nosyndrome">-</span></div>
      </div>

      <div class="log expert-only">
        <h2>Event log</h2>
        <ul id="log-list"></ul>
      </div>
    </aside>

    <main class="panel game-surface">
      <div class="board-wrapper">
        <div class="board-meta">
          <div><strong>Current level:</strong> <span id="level-label"></span></div>
          <div><strong>Rounds (overall):</strong> <span id="target-rounds">0/0</span></div>
        </div>
        <div class="board" id="board" aria-live="polite"></div>
        <p class="status-line" id="status-line" role="status" aria-live="polite"></p>
        <div class="actions" style="margin-top: 18px;">
          <button type="button" class="ghost" id="auto-advance-toggle">Auto-advance On</button>
          <button type="button" class="primary button-progress" id="next-round" disabled>Continue</button>
        </div>
      </div>

      <section class="summary-card" id="summary-card">
        <h2>Session summary</h2>
        <p>Final statistics for this run. They are stored in the database.</p>
        <pre id="summary-output">No data yet.</pre>
      </section>
    </main>
  </div>

  <div class="overlay" id="data-overlay" role="dialog" aria-modal="true" aria-labelledby="overlay-title">
    <div class="overlay-card">
      <button class="overlay-close" id="overlay-close" aria-label="Close">x</button>
      <h2 id="overlay-title">Stored game runs</h2>
      <pre id="overlay-output">Loading...</pre>
    </div>
  </div>

  <div class="overlay" id="stats-overlay" role="dialog" aria-modal="true" aria-labelledby="stats-overlay-title">
    <div class="overlay-card">
      <button class="overlay-close" id="stats-overlay-close" aria-label="Close">x</button>
      <h2 id="stats-overlay-title">Logical error rates</h2>
      <div id="stats-overlay-output" class="stats-overlay-content">Loading...</div>
    </div>
  </div>

  <script id="config-data" type="application/json">
    {{ {
      "grid_sizes": grid_sizes,
      "levels": levels,
      "level_count": level_count,
      "allowed_level_counts": allowed_level_counts,
      "level_bounds": level_bounds,
      "level_precision": level_precision,
      "rounds_per_level": rounds_per_level,
      "allowed_rounds": allowed_rounds
    } | tojson }}
  </script>

  <script>
    (function() {
      const config = JSON.parse(document.getElementById('config-data').textContent);
      const allowedSizes = Array.isArray(config.grid_sizes) ? config.grid_sizes : [];
      const defaultLevels = Array.isArray(config.levels) ? config.levels : [];
      const boundsArray = Array.isArray(config.level_bounds) ? config.level_bounds : [];
      const minProbability = Number(boundsArray[0]);
      const maxProbability = Number(boundsArray[1]);
      const precisionValue = Number(config.level_precision);
      const levelPrecision = Number.isInteger(precisionValue) && precisionValue >= 0 ? precisionValue : 3;
      const allowedLevelCounts = (config.allowed_level_counts || [])
        .map((value) => Number(value))
        .filter((value) => Number.isFinite(value) && value > 0)
        .sort((a, b) => a - b);
      const rawLevelCount = Number(config.level_count);

      function generateLevels(count) {
        const min = Number.isFinite(minProbability) ? minProbability : 0.01;
        const max = Number.isFinite(maxProbability) ? maxProbability : min;
        const precision = levelPrecision;
        const safeCount = Math.max(1, Math.floor(Number(count) || 0));
        if (safeCount === 1 || max === min) {
          return [Number(min.toFixed(precision))];
        }
        const step = (max - min) / (safeCount - 1);
        const levels = [];
        for (let i = 0; i < safeCount; i += 1) {
          const value = min + step * i;
          levels.push(Number(value.toFixed(precision)));
        }
        return levels;
      }

      let selectedLevelCount = Number.isFinite(rawLevelCount) ? Math.max(1, Math.floor(rawLevelCount)) : (defaultLevels.length || 3);
      if (allowedLevelCounts.length && !allowedLevelCounts.includes(selectedLevelCount)) {
        selectedLevelCount = allowedLevelCounts[0];
      } else if (!allowedLevelCounts.length && selectedLevelCount < 1) {
        selectedLevelCount = 1;
      }

      const baseLevelCount = selectedLevelCount;

      let initialLevels = defaultLevels.slice();
      if (initialLevels.length !== selectedLevelCount) {
        initialLevels = generateLevels(selectedLevelCount);
      }

      const allowedRoundOptions = (config.allowed_rounds || []).map((value) => Number(value));
      let targetInteractiveRounds = Number(config.rounds_per_level);
      if (!Number.isFinite(targetInteractiveRounds) || !allowedRoundOptions.includes(targetInteractiveRounds)) {
        targetInteractiveRounds = allowedRoundOptions.length ? allowedRoundOptions[0] : 3;
      }

      const baseRoundsPerLevel = targetInteractiveRounds;

      const startBtn = document.getElementById('start-game');
      const resetBtn = document.getElementById('reset-game');
      const showStatsBtn = document.getElementById('show-stats');
      const showDataBtn = document.getElementById('show-data');
      const nextRoundBtn = document.getElementById('next-round');
      const autoAdvanceToggle = document.getElementById('auto-advance-toggle');
      const expertToggle = document.getElementById('expert-toggle');
      const selectD = document.getElementById('config-d');
      const selectRounds = document.getElementById('config-rounds');
      const selectLevels = document.getElementById('config-levels');
      const playerNameInput = document.getElementById('player-name');
      const boardWrapper = document.querySelector('.board-wrapper');
      const boardEl = document.getElementById('board');
      const statusLine = document.getElementById('status-line');
      const levelLabel = document.getElementById('level-label');
      const targetRoundsLabel = document.getElementById('target-rounds');
      const summaryCard = document.getElementById('summary-card');
      const summaryOutput = document.getElementById('summary-output');
      const overlay = document.getElementById('data-overlay');
      const overlayOutput = document.getElementById('overlay-output');
      const overlayClose = document.getElementById('overlay-close');
      const statsOverlay = document.getElementById('stats-overlay');
      const statsOverlayOutput = document.getElementById('stats-overlay-output');
      const statsOverlayClose = document.getElementById('stats-overlay-close');
      const logList = document.getElementById('log-list');
      const statLevel = document.getElementById('stat-level');
      const statRound = document.getElementById('stat-round');
      const statLogical = document.getElementById('stat-logical');
      const statNoSyndrome = document.getElementById('stat-nosyndrome');
      const expertControls = document.querySelectorAll('[data-expert-control]');
      const AUTO_ADVANCE_DELAY_MS = 1000;

      if (selectRounds) {
        selectRounds.value = String(targetInteractiveRounds);
      }
      if (selectLevels) {
        selectLevels.value = String(selectedLevelCount);
      }

      const state = {
        running: false,
        surface: null,
        qubitButtons: [],
        stabilizerWidgets: [],
        sessionId: null,
        playerName: null,
        expertMode: Boolean(expertToggle && expertToggle.checked),
        levelIndex: 0,
        levels: initialLevels.slice(),
        levelCount: selectedLevelCount,
        levelStats: null,
        levelsData: [],
        current: null,
        autoTimer: null,
        autoAdvanceEnabled: true,
      };

      let boardScaleFrameId = null;

      function parseCssNumber(value) {
        const parsed = Number.parseFloat(value);
        return Number.isFinite(parsed) ? parsed : 0;
      }

      function updateBoardScale() {
        if (!boardEl) {
          return;
        }
        const boardSizeRaw = boardEl.style.getPropertyValue('--board-size');
        const boardSize = Number.parseInt(boardSizeRaw, 10);
        if (!Number.isFinite(boardSize) || boardSize <= 0) {
          boardEl.style.setProperty('--board-scale', '1');
          return;
        }
        boardEl.style.setProperty('--board-scale', '1');
        const styles = window.getComputedStyle(boardEl);
        const paddingLeft = parseCssNumber(styles.paddingLeft);
        const paddingRight = parseCssNumber(styles.paddingRight);
        const gap = parseCssNumber(styles.getPropertyValue('--cell-gap'));
        const baseCellMin = parseCssNumber(styles.getPropertyValue('--cell-min-size'));
        if (!Number.isFinite(baseCellMin) || baseCellMin <= 0) {
          boardEl.style.setProperty('--board-scale', '1');
          return;
        }
        const contentWidth = boardEl.clientWidth - paddingLeft - paddingRight;
        if (!Number.isFinite(contentWidth) || contentWidth <= 0) {
          boardEl.style.setProperty('--board-scale', '1');
          return;
        }
        const totalGap = gap * Math.max(0, boardSize - 1);
        const available = contentWidth - totalGap;
        if (!Number.isFinite(available) || available <= 0) {
          boardEl.style.setProperty('--board-scale', '1');
          return;
        }
        const targetSize = available / boardSize;
        if (!Number.isFinite(targetSize) || targetSize >= baseCellMin) {
          boardEl.style.setProperty('--board-scale', '1');
          return;
        }
        const scale = targetSize / baseCellMin;
        if (!Number.isFinite(scale) || scale >= 1 || scale <= 0) {
          boardEl.style.setProperty('--board-scale', '1');
          return;
        }
        boardEl.style.setProperty('--board-scale', scale.toFixed(4));
      }

      function requestBoardScale() {
        if (typeof window.requestAnimationFrame !== 'function') {
          updateBoardScale();
          return;
        }
        if (boardScaleFrameId !== null) {
          window.cancelAnimationFrame(boardScaleFrameId);
        }
        boardScaleFrameId = window.requestAnimationFrame(() => {
          boardScaleFrameId = null;
          updateBoardScale();
        });
      }

      function setStatus(message, isError) {
        statusLine.textContent = message || '';
        statusLine.classList.toggle('error', Boolean(isError));
      }

      function addLog(message) {
        const entry = document.createElement('li');
        entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
        logList.prepend(entry);
        while (logList.children.length > 40) {
          logList.removeChild(logList.lastChild);
        }
      }

      function clearAutoTimer() {
        if (state.autoTimer !== null) {
          window.clearTimeout(state.autoTimer);
          state.autoTimer = null;
        }
        if (nextRoundBtn) {
          nextRoundBtn.classList.remove('active');
          nextRoundBtn.style.removeProperty('--progress');
          nextRoundBtn.style.removeProperty('--auto-duration');
        }
      }

      function maybeScheduleAutoContinue() {
        clearAutoTimer();
        if (
          !state.running ||
          !state.autoAdvanceEnabled ||
          !state.current ||
          !nextRoundBtn ||
          nextRoundBtn.disabled
        ) {
          return;
        }
        const duration = AUTO_ADVANCE_DELAY_MS;
        nextRoundBtn.style.setProperty('--auto-duration', duration + 'ms');
        nextRoundBtn.classList.add('active');
        state.autoTimer = window.setTimeout(() => {
          state.autoTimer = null;
          if (nextRoundBtn) {
            nextRoundBtn.classList.remove('active');
            nextRoundBtn.style.removeProperty('--progress');
          }
          if (
            state.running &&
            state.autoAdvanceEnabled &&
            state.current &&
            nextRoundBtn &&
            !nextRoundBtn.disabled
          ) {
            handleContinue();
          }
        }, AUTO_ADVANCE_DELAY_MS);
      }

      function updateAutoAdvanceToggle() {
        if (!autoAdvanceToggle) {
          return;
        }
        const label = state.autoAdvanceEnabled ? 'Auto-advance On' : 'Auto-advance Off';
        autoAdvanceToggle.textContent = label;
        autoAdvanceToggle.classList.toggle('is-off', !state.autoAdvanceEnabled);
        autoAdvanceToggle.setAttribute('aria-pressed', state.autoAdvanceEnabled ? 'true' : 'false');
      }

      function setAutoAdvanceEnabled(enabled) {
        const normalized = Boolean(enabled);
        state.autoAdvanceEnabled = normalized;
        updateAutoAdvanceToggle();
        if (!normalized) {
          clearAutoTimer();
        } else if (state.running && state.current) {
          maybeScheduleAutoContinue();
        }
      }

      function aggregateLogicalErrorStats(records) {
        const gridMap = new Map();
        (records || []).forEach((record) => {
          const gridSize = Number(record.grid_size);
          if (!Number.isFinite(gridSize)) {
            return;
          }
          const probabilityStats = Array.isArray(record.probability_stats) ? record.probability_stats : [];
          const playerNameRaw = typeof record.name === 'string' ? record.name : '';
          const playerName = playerNameRaw.trim() || 'Anonymous';
          if (!gridMap.has(gridSize)) {
            gridMap.set(gridSize, new Map());
          }
          const probMap = gridMap.get(gridSize);
          probabilityStats.forEach((entry) => {
            const probability = Number(entry.probability);
            const totalRounds = Number(entry.total_rounds);
            const logicalFailures = Number(entry.logical_failures);
            if (!Number.isFinite(probability) || totalRounds <= 0 || !Number.isFinite(logicalFailures) || logicalFailures < 0) {
              return;
            }
            let accumulator = probMap.get(probability);
            if (!accumulator) {
              accumulator = { totalRounds: 0, logicalFailures: 0, byName: new Map() };
              probMap.set(probability, accumulator);
            }
            accumulator.totalRounds += totalRounds;
            accumulator.logicalFailures += logicalFailures;

            const byNameMap = accumulator.byName;
            let nameAccumulator = byNameMap.get(playerName);
            if (!nameAccumulator) {
              nameAccumulator = { totalRounds: 0, logicalFailures: 0 };
              byNameMap.set(playerName, nameAccumulator);
            }
            nameAccumulator.totalRounds += totalRounds;
            nameAccumulator.logicalFailures += logicalFailures;
          });
        });

        const result = [];
        gridMap.forEach((probMap, gridSize) => {
          const points = [];
          let totals = { totalRounds: 0, logicalFailures: 0 };
          probMap.forEach((accumulator, probability) => {
            if (accumulator.totalRounds <= 0) {
              return;
            }
            const ler = accumulator.logicalFailures / accumulator.totalRounds;
            const variance = ler * (1 - ler) / accumulator.totalRounds;
            const stderr = Number.isFinite(variance) && variance > 0 ? Math.sqrt(variance) : 0;
            let bestName = null;
            let bestRate = Infinity;
            let bestRounds = 0;
            const EPSILON = 1e-9;
            (accumulator.byName || new Map()).forEach((value, name) => {
              if (!value || value.totalRounds <= 0) {
                return;
              }
              const nameRate = value.logicalFailures / value.totalRounds;
              if (!Number.isFinite(nameRate)) {
                return;
              }
              const betterRate = nameRate < bestRate - EPSILON;
              const similarRate = Math.abs(nameRate - bestRate) <= EPSILON;
              const moreRounds = value.totalRounds > bestRounds;
              const tieBreaker = bestName === null || name.localeCompare(bestName, undefined, { sensitivity: 'base' }) < 0;
              if (betterRate || (similarRate && (moreRounds || (value.totalRounds === bestRounds && tieBreaker)))) {
                bestRate = nameRate;
                bestName = name;
                bestRounds = value.totalRounds;
              }
            });
            points.push({
              probability,
              totalRounds: accumulator.totalRounds,
              logicalFailures: accumulator.logicalFailures,
              logicalErrorRate: ler,
              stderr,
              bestName,
              bestRate: Number.isFinite(bestRate) ? bestRate : null,
            });
            totals.totalRounds += accumulator.totalRounds;
            totals.logicalFailures += accumulator.logicalFailures;
          });
          if (points.length) {
            points.sort((a, b) => a.probability - b.probability);
            result.push({ gridSize, points, totals });
          }
        });
        result.sort((a, b) => a.gridSize - b.gridSize);
        return result;
      }

      function drawStatsChart(canvas, seriesList) {
        if (!canvas || !canvas.getContext || !Array.isArray(seriesList) || !seriesList.length) {
          return;
        }
        const usableSeries = seriesList
          .map((series) => ({
            gridSize: series.gridSize,
            color: series.color || 'rgba(120, 200, 255, 0.9)',
            points: Array.isArray(series.points) ? series.points.slice() : [],
          }))
          .map((series) => {
            series.points.sort((a, b) => a.probability - b.probability);
            return series;
          })
          .filter((series) => series.points.length);
        if (!usableSeries.length) {
          return;
        }

        const allPoints = usableSeries.flatMap((series) => series.points);
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const cssWidth = canvas.clientWidth || canvas.width || 560;
        const cssHeight = canvas.clientHeight || canvas.height || 280;
        const actualWidth = Math.max(1, Math.round(cssWidth * dpr));
        const actualHeight = Math.max(1, Math.round(cssHeight * dpr));
        if (canvas.width !== actualWidth) {
          canvas.width = actualWidth;
        }
        if (canvas.height !== actualHeight) {
          canvas.height = actualHeight;
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, actualWidth, actualHeight);
        ctx.scale(dpr, dpr);
        const width = cssWidth;
        const height = cssHeight;

        const margin = 48;
        const chartWidth = width - margin * 2;
        const chartHeight = height - margin * 2;
        const minProb = 0;
        const maxProb = Math.max(...allPoints.map((p) => p.probability), 0.01);
        let maxRate = Math.max(...allPoints.map((p) => p.logicalErrorRate + p.stderr), 0.001);
        if (!Number.isFinite(maxRate) || maxRate <= 0) {
          maxRate = 0.001;
        }
        const paddedMaxRate = maxRate * 1.2;

        const probRange = Math.max(maxProb - minProb, 0.001);
        const rateRange = Math.max(paddedMaxRate, 0.001);

        const projectX = (probability) => {
          return margin + ((probability - minProb) / probRange) * chartWidth;
        };
        const projectY = (rate) => {
          return margin + chartHeight - Math.max(0, Math.min(rate, rateRange)) / rateRange * chartHeight;
        };

        ctx.save();
        ctx.strokeStyle = 'rgba(120, 150, 255, 0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(margin, margin);
        ctx.lineTo(margin, margin + chartHeight);
        ctx.lineTo(margin + chartWidth, margin + chartHeight);
        ctx.stroke();

        ctx.fillStyle = 'rgba(200, 210, 255, 0.65)';
        ctx.font = '12px "Inter", sans-serif';
        ctx.textBaseline = 'middle';
        const tickCount = 4;
        for (let i = 0; i <= tickCount; i += 1) {
          const rateValue = (rateRange / tickCount) * i;
          const y = projectY(rateValue);
          ctx.strokeStyle = 'rgba(120, 150, 255, 0.12)';
          ctx.beginPath();
          ctx.moveTo(margin, y);
          ctx.lineTo(margin + chartWidth, y);
          ctx.stroke();
          ctx.fillText(rateValue.toExponential(1), margin - 6, y);
        }

        ctx.textBaseline = 'top';
        const xTickCount = Math.min(Math.max(allPoints.length, 1), 6);
        for (let i = 0; i <= xTickCount; i += 1) {
          const ratio = xTickCount ? i / xTickCount : 0;
          const probValue = minProb + ratio * probRange;
          const x = projectX(probValue);
          ctx.strokeStyle = 'rgba(120, 150, 255, 0.12)';
          ctx.beginPath();
          ctx.moveTo(x, margin);
          ctx.lineTo(x, margin + chartHeight);
          ctx.stroke();
          ctx.fillStyle = 'rgba(200, 210, 255, 0.65)';
          ctx.fillText(probValue.toFixed(3), x - 12, margin + chartHeight + 6);
        }

        usableSeries.forEach((series) => {
          ctx.save();
          ctx.strokeStyle = series.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          series.points.forEach((point, index) => {
            const x = projectX(point.probability);
            const y = projectY(point.logicalErrorRate);
            if (index === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          ctx.stroke();

          ctx.lineWidth = 1;
          series.points.forEach((point) => {
            const x = projectX(point.probability);
            const yCenter = projectY(point.logicalErrorRate);
            const yTop = projectY(point.logicalErrorRate + point.stderr);
            const yBottom = projectY(Math.max(point.logicalErrorRate - point.stderr, 0));
            ctx.strokeStyle = series.color;
            ctx.beginPath();
            ctx.moveTo(x, yTop);
            ctx.lineTo(x, yBottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x - 4, yTop);
            ctx.lineTo(x + 4, yTop);
            ctx.moveTo(x - 4, yBottom);
            ctx.lineTo(x + 4, yBottom);
            ctx.stroke();

            ctx.fillStyle = series.color;
            ctx.beginPath();
            ctx.arc(x, yCenter, 3, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.restore();
        });
        ctx.restore();

        ctx.fillStyle = 'rgba(210, 220, 255, 0.75)';
        ctx.font = '12px "Inter", sans-serif';
        ctx.fillText('Physical error probability', margin + chartWidth / 2 - 80, height - 12);
        ctx.save();
        ctx.translate(14, margin + chartHeight / 2 + 60);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Logical error rate', 0, 0);
        ctx.restore();
      }

      function formatRate(value) {
        if (!Number.isFinite(value) || value < 0) {
          return '0.0000';
        }
        if (value === 0) {
          return '0.0000';
        }
        if (value < 1e-4) {
          return value.toExponential(2);
        }
        return value.toFixed(4);
      }

      function renderStatsOverlayContent(sections) {
        if (!statsOverlayOutput) {
          return;
        }
        statsOverlayOutput.textContent = '';
        if (!sections.length) {
          const emptyMessage = document.createElement('p');
          emptyMessage.textContent = 'Not enough data yet. Play a few sessions to generate statistics.';
          statsOverlayOutput.appendChild(emptyMessage);
          return;
        }
        const palette = ['#7dd3fc', '#fca5a5', '#fcd34d', '#c4b5fd', '#86efac', '#f9a8d4', '#f97316', '#fbbf24'];
        const seriesList = sections
          .map((section, index) => ({
            gridSize: section.gridSize,
            points: Array.isArray(section.points) ? section.points : [],
            totals: section.totals || { totalRounds: 0, logicalFailures: 0 },
            color: palette[index % palette.length],
          }))
          .filter((section) => section.points.length);

        if (!seriesList.length) {
          const emptyMessage = document.createElement('p');
          emptyMessage.textContent = 'Not enough data yet. Play a few sessions to generate statistics.';
          statsOverlayOutput.appendChild(emptyMessage);
          return;
        }

        const container = document.createElement('section');
        container.className = 'stats-section';

        const header = document.createElement('h3');
        const totalRoundsAll = seriesList.reduce((total, series) => total + (series.totals.totalRounds || 0), 0);
        header.textContent = 'Logical error rates by code distance (' + totalRoundsAll.toLocaleString() + ' rounds)';
        container.appendChild(header);

        const canvas = document.createElement('canvas');
        canvas.width = 560;
        canvas.height = 280;
        canvas.className = 'stats-chart';
        container.appendChild(canvas);
        drawStatsChart(canvas, seriesList);

        const legend = document.createElement('div');
        legend.className = 'stats-legend';
        seriesList.forEach((series) => {
          const item = document.createElement('span');
          item.className = 'stats-legend-item';
          const swatch = document.createElement('span');
          swatch.className = 'stats-legend-swatch';
          swatch.style.backgroundColor = series.color;
          swatch.style.borderColor = series.color;
          item.appendChild(swatch);
          const label = document.createElement('span');
          label.textContent = 'd = ' + series.gridSize;
          item.appendChild(label);
          legend.appendChild(item);
        });
        container.appendChild(legend);

        const table = document.createElement('table');
        table.className = 'stats-table';
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Distance</th><th>Probability</th><th>Total rounds</th><th>Logical failures</th><th>Logical error rate</th><th>Std. error</th><th>Best score</th></tr>';
        table.appendChild(thead);
        const tbody = document.createElement('tbody');

        const tableRows = [];
        seriesList.forEach((series) => {
          series.points.forEach((point) => {
            tableRows.push({ series, point });
          });
        });
        tableRows.sort((a, b) => {
          if (a.series.gridSize !== b.series.gridSize) {
            return a.series.gridSize - b.series.gridSize;
          }
          return a.point.probability - b.point.probability;
        });

        tableRows.forEach(({ series, point }) => {
          const row = document.createElement('tr');
          const stderrValue = Number.isFinite(point.stderr) ? point.stderr : 0;
          const bestSummary = point.bestName && Number.isFinite(point.bestRate)
            ? point.bestName + ' (' + formatRate(point.bestRate) + ')'
            : '—';
          row.innerHTML = [
            'd = ' + series.gridSize,
            point.probability.toFixed(3),
            point.totalRounds.toLocaleString(),
            point.logicalFailures.toLocaleString(),
            formatRate(point.logicalErrorRate),
            formatRate(stderrValue),
            bestSummary,
          ]
            .map((value) => '<td>' + value + '</td>')
            .join('');
          tbody.appendChild(row);
        });

        table.appendChild(tbody);
        const tableWrapper = document.createElement('div');
        tableWrapper.className = 'stats-table-wrapper';
        tableWrapper.appendChild(table);
        container.appendChild(tableWrapper);

        const summaryList = document.createElement('ul');
        summaryList.className = 'stats-summary-list';
        seriesList.forEach((series) => {
          const item = document.createElement('li');
          const lerOverall = series.totals.totalRounds > 0
            ? series.totals.logicalFailures / series.totals.totalRounds
            : 0;
          item.innerHTML = '<strong>d = ' + series.gridSize + '</strong> · ' + formatRate(lerOverall) + ' (' + series.totals.logicalFailures.toLocaleString() + ' / ' + series.totals.totalRounds.toLocaleString() + ')';
          summaryList.appendChild(item);
        });
        container.appendChild(summaryList);

        statsOverlayOutput.appendChild(container);
      }

      function showStatsOverlay() {
        if (!statsOverlay) {
          return;
        }
        statsOverlay.classList.add('visible');
        if (statsOverlayOutput) {
          statsOverlayOutput.textContent = 'Loading...';
        }
        fetch('/api/game/data')
          .then((response) => {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status);
            }
            return response.json();
          })
          .then((records) => {
            const sections = aggregateLogicalErrorStats(records);
            renderStatsOverlayContent(sections);
          })
          .catch((error) => {
            if (statsOverlayOutput) {
              statsOverlayOutput.textContent = 'Failed to load statistics: ' + error.message;
            }
          });
      }

      function hideStatsOverlay(event) {
        if (!statsOverlay) {
          return;
        }
        if (!event || event.target === statsOverlay || event.target === statsOverlayClose) {
          statsOverlay.classList.remove('visible');
        }
      }

      function setExpertControlsDisabled(disabled) {
        expertControls.forEach((element) => {
          if (!element) {
            return;
          }
          element.disabled = disabled;
          if (disabled) {
            element.classList.remove('active');
            element.style.removeProperty('--progress');
            element.style.removeProperty('--auto-duration');
          }
        });
      }

      function applyExpertMode(isExpert) {
        state.expertMode = isExpert;
        document.body.classList.toggle('expert-mode', isExpert);
        setExpertControlsDisabled(!isExpert);
        if (!isExpert) {
          if (playerNameInput) {
            playerNameInput.value = '';
          }
          if (!state.running) {
            selectedLevelCount = baseLevelCount;
            state.levelCount = baseLevelCount;
            state.levels = generateLevels(baseLevelCount);
            if (selectLevels) {
              selectLevels.value = String(baseLevelCount);
            }
            targetInteractiveRounds = baseRoundsPerLevel;
            if (selectRounds) {
              selectRounds.value = String(targetInteractiveRounds);
            }
          }
        } else if (selectLevels) {
          selectLevels.value = String(selectedLevelCount);
        }
        updateBoardLabels();
        renderStats();
      }

      function ensureBoardVisibility() {
        if (!boardWrapper) {
          return;
        }
        const compactLayout = window.matchMedia('(max-width: 960px)').matches;
        if (!compactLayout) {
          return;
        }
        const scrollToBoard = () => {
          boardWrapper.scrollIntoView({ block: 'start', behavior: 'smooth' });
        };
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(() => {
            window.setTimeout(scrollToBoard, 60);
          });
        } else {
          window.setTimeout(scrollToBoard, 60);
        }
      }

      function clearBoard() {
        boardEl.textContent = '';
        boardEl.style.setProperty('--board-size', 1);
        boardEl.style.setProperty('--board-scale', '1');
        const placeholder = document.createElement('div');
        placeholder.className = 'cell placeholder';
        placeholder.textContent = 'Select a distance and press Start Game.';
        boardEl.appendChild(placeholder);
        state.qubitButtons = [];
        state.stabilizerWidgets = [];
        updateBoardScale();
        requestBoardScale();
      }

      class SurfaceCode {
        constructor(distance) {
          this.d = distance;
          this.dataQubits = [];
          this.stabilizers = [];
          this.matrixH = [];
          this.logicalVector = [];
          this.build();
        }

        build() {
          const d = this.d;
          let idx = 0;
          for (let row = 0; row < d; row += 1) {
            for (let col = 0; col < d; col += 1) {
              this.dataQubits.push({ idx: idx++, row, col, isEdge: col === 0 });
            }
          }
          for (let row = 0; row < d - 1; row += 1) {
            for (let col = 0; col < d - 1; col += 1) {
              this.dataQubits.push({ idx: idx++, row: row + 0.5, col: col + 0.5, isEdge: false });
            }
          }

          const neighborsFor = (row, col) => {
            const close = (a, b) => Math.abs(a - b) < 1e-6;
            return this.dataQubits
              .filter((q) =>
                (close(q.row, row - 0.5) && close(q.col, col)) ||
                (close(q.row, row + 0.5) && close(q.col, col)) ||
                (close(q.row, row) && close(q.col, col - 0.5)) ||
                (close(q.row, row) && close(q.col, col + 0.5)))
              .map((q) => q.idx);
          };

          let sIdx = 0;
          for (let row = 0; row < d; row += 1) {
            for (let col = 0; col < d - 1; col += 1) {
              const colMid = col + 0.5;
              const neighborList = neighborsFor(row, colMid);
              this.stabilizers.push({ idx: sIdx, row, col: colMid, neighbors: neighborList });
              this.matrixH.push(neighborList);
              sIdx += 1;
            }
          }

          this.logicalVector = this.dataQubits.map((q) => (q.col === 0 ? 1 : 0));
        }

        syndrome(vector) {
          return this.matrixH.map((indices) => {
            let total = 0;
            for (const idx of indices) {
              total ^= vector[idx];
            }
            return total;
          });
        }

        logicalParity(vector) {
          let total = 0;
          for (let i = 0; i < vector.length; i += 1) {
            if (this.logicalVector[i]) {
              total ^= vector[i];
            }
          }
          return total;
        }
      }

      function buildBoard(surface) {
        boardEl.textContent = '';
        const size = surface.d * 2 - 1;
        boardEl.style.setProperty('--board-size', size);
        boardEl.style.setProperty('--board-scale', '1');
        const cells = Array.from({ length: size * size }, () => {
          const wrapper = document.createElement('div');
          wrapper.className = 'cell empty';
          boardEl.appendChild(wrapper);
          return wrapper;
        });

        const indexFor = (row, col) => row * size + col;

        state.qubitButtons = surface.dataQubits.map((q) => {
          const r = Math.round(q.row * 2);
          const c = Math.round(q.col * 2);
          const button = document.createElement('button');
          button.className = 'qubit';
          button.type = 'button';
          const label = String(q.idx);
          button.dataset.idx = label;
          button.dataset.label = label;
          button.textContent = state.expertMode ? label : '';
          button.disabled = true;
          button.addEventListener('click', () => handleQubitFlip(q.idx));
          const cell = cells[indexFor(r, c)];
          cell.classList.remove('empty');
          cell.appendChild(button);
          return button;
        });

        state.stabilizerWidgets = surface.stabilizers.map((s) => {
          const r = Math.round(s.row * 2);
          const c = Math.round(s.col * 2);
          const span = document.createElement('div');
          span.className = 'stabilizer';
          const label = String(s.idx);
          span.dataset.label = label;
          span.textContent = state.expertMode ? label : '';
          const cell = cells[indexFor(r, c)];
          cell.classList.remove('empty');
          cell.appendChild(span);
          return span;
        });

        updateBoardLabels();
        updateBoardScale();
        requestBoardScale();
      }

      function updateBoardMarkers() {
        if (!state.current) {
          return;
        }
        const { error, correction, residual, syndrome } = state.current;
        const showErrors = sumVector(syndrome) === 0;

        state.qubitButtons.forEach((btn, idx) => {
          const hasInitialError = showErrors && Boolean(error[idx]);
          btn.classList.toggle('has-error', hasInitialError);
          btn.classList.toggle('corrected', Boolean(correction[idx]));
          btn.classList.toggle('residual', showErrors && Boolean(residual[idx]));
        });

        state.stabilizerWidgets.forEach((widget, idx) => {
          widget.classList.toggle('active', Boolean(syndrome[idx]));
        });
      }

      function updateBoardLabels() {
        const showLabels = Boolean(state.expertMode);
        state.qubitButtons.forEach((btn) => {
          const label = btn.dataset.label || '';
          btn.textContent = showLabels ? label : '';
        });
        state.stabilizerWidgets.forEach((widget) => {
          const label = widget.dataset.label || '';
          widget.textContent = showLabels ? label : '';
        });
      }

      function setControlsEnabled(enabled) {
        state.qubitButtons.forEach((btn) => {
          btn.disabled = !enabled;
        });
      }

      function randomVector(length, probability) {
        const vector = new Array(length);
        for (let i = 0; i < length; i += 1) {
          vector[i] = Math.random() < probability ? 1 : 0;
        }
        return vector;
      }

      function sumVector(vector) {
        return vector.reduce((total, value) => total + value, 0);
      }

      function handleQubitFlip(idx) {
        if (!state.running || !state.current) {
          return;
        }
        const current = state.current;
        current.correction[idx] ^= 1;
        current.residual[idx] = current.error[idx] ^ current.correction[idx];
        current.syndrome = state.surface.syndrome(current.residual);
        updateBoardMarkers();

        const weight = sumVector(current.syndrome);
        if (weight === 0) {
          setControlsEnabled(false);
          nextRoundBtn.disabled = false;
          const levelStats = state.levelStats;
          levelStats.withSyndrome += 1;
          if (state.surface.logicalParity(current.residual) === 1) {
            levelStats.logicalErrors += 1;
            levelStats.events.push({ type: 'logical_error', round: levelStats.withSyndrome });
            setStatus('Logical error detected. Continue to the next round.', true);
            addLog('Logical error recorded for this level.');
          } else {
            levelStats.events.push({ type: 'success', round: levelStats.withSyndrome });
            setStatus('Syndrome cleared. No logical error.', false);
            addLog('Syndrome cleared without logical error.');
          }
          renderStats();
          if (levelStats.withSyndrome >= targetInteractiveRounds) {
            addLog('Target number of rounds with syndrome reached for this level.');
          }
          maybeScheduleAutoContinue();
        } else {
          setStatus('Syndrome weight ' + weight + '. Continue correcting.');
        }
      }

      function renderStats() {
        if (state.running && state.levelStats) {
          statLevel.textContent = (state.levelIndex + 1) + ' / ' + state.levels.length;
          statRound.textContent = state.levelStats.withSyndrome + '/' + targetInteractiveRounds;
          statLogical.textContent = String(state.levelStats.logicalErrors);
          statNoSyndrome.textContent = String(state.levelStats.withoutSyndrome);
        } else {
          statLevel.textContent = '-';
          statRound.textContent = '-';
          statLogical.textContent = '-';
          statNoSyndrome.textContent = '-';
        }
        const totalInteractiveRounds = state.levels.length * targetInteractiveRounds;
        let completedInteractiveRounds = (state.levelsData || []).reduce((sum, level) => {
          return sum + (Number(level.interactive_rounds) || 0);
        }, 0);
        if (state.running && state.levelStats) {
          completedInteractiveRounds += state.levelStats.withSyndrome;
        }
        if (targetRoundsLabel) {
          if (totalInteractiveRounds > 0) {
            targetRoundsLabel.textContent = completedInteractiveRounds + '/' + totalInteractiveRounds;
          } else {
            targetRoundsLabel.textContent = '0/0';
          }
        }
        if (selectRounds && selectRounds.value !== String(targetInteractiveRounds)) {
          selectRounds.value = String(targetInteractiveRounds);
        }
        if (selectLevels && selectLevels.value !== String(selectedLevelCount)) {
          selectLevels.value = String(selectedLevelCount);
        }
      }

      function handleRoundsChange() {
        if (!selectRounds) {
          return;
        }
        if (!state.expertMode) {
          selectRounds.value = String(targetInteractiveRounds);
          return;
        }
        const chosen = Number.parseInt(selectRounds.value, 10);
        if (!Number.isFinite(chosen) || !allowedRoundOptions.includes(chosen)) {
          return;
        }
        if (targetInteractiveRounds === chosen) {
          return;
        }
        targetInteractiveRounds = chosen;
        addLog('Rounds per level set to ' + chosen + '.');
        renderStats();
      }

      function handleLevelsChange() {
        if (!selectLevels) {
          return;
        }
        if (!state.expertMode) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        const chosen = Number.parseInt(selectLevels.value, 10);
        if (!Number.isFinite(chosen)) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        const normalized = Math.max(1, Math.floor(chosen));
        if (allowedLevelCounts.length && !allowedLevelCounts.includes(normalized)) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        if (state.running) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        if (selectedLevelCount === normalized) {
          return;
        }
        selectedLevelCount = normalized;
        state.levelCount = normalized;
        state.levels = generateLevels(normalized);
        addLog('Levels per run set to ' + normalized + '.');
        renderStats();
      }

      function resetState() {
        clearAutoTimer();
        state.running = false;
        state.surface = null;
        state.qubitButtons = [];
        state.stabilizerWidgets = [];
        state.sessionId = null;
        state.playerName = null;
        state.levelIndex = 0;
        state.levelCount = selectedLevelCount;
        state.levels = generateLevels(selectedLevelCount);
        state.levelStats = null;
        state.levelsData = [];
        state.current = null;
        nextRoundBtn.disabled = true;
        summaryCard.classList.remove('visible');
        summaryOutput.textContent = 'No data yet.';
        levelLabel.textContent = '-';
        setStatus('', false);
        clearBoard();
        startBtn.disabled = false;
        if (expertToggle) {
          applyExpertMode(Boolean(expertToggle.checked));
        } else {
          renderStats();
        }
        updateAutoAdvanceToggle();
      }

      function startGame() {
        const distance = Number.parseInt(selectD.value, 10);
        if (!allowedSizes.includes(distance)) {
          setStatus('Unknown code distance selected.', true);
          return;
        }
        const isExpert = Boolean(expertToggle && expertToggle.checked);
        let playerName = '';
        if (isExpert && playerNameInput) {
          playerName = playerNameInput.value.trim();
        }
        if (isExpert && selectRounds) {
          const selectedRounds = Number.parseInt(selectRounds.value, 10);
          if (Number.isFinite(selectedRounds) && allowedRoundOptions.includes(selectedRounds)) {
            targetInteractiveRounds = selectedRounds;
          }
        }
        if (isExpert && selectLevels) {
          const selectedLevels = Number.parseInt(selectLevels.value, 10);
          if (Number.isFinite(selectedLevels)) {
            const normalized = Math.max(1, Math.floor(selectedLevels));
            if (!allowedLevelCounts.length || allowedLevelCounts.includes(normalized)) {
              selectedLevelCount = normalized;
            }
          }
        }
        resetState();
        state.playerName = state.expertMode && playerName ? playerName : null;
        state.running = true;
        state.surface = new SurfaceCode(distance);
        state.sessionId = uuid();
        startBtn.disabled = true;
        if (state.expertMode && selectRounds) {
          selectRounds.disabled = true;
        }
        if (state.expertMode && selectLevels) {
          selectLevels.disabled = true;
        }
        if (selectLevels) {
          selectLevels.value = String(selectedLevelCount);
        }
        const sessionLog = 'New session ' + state.sessionId + ' started with d=' + distance + (state.playerName ? ' for ' + state.playerName : '') + '.';
        addLog(sessionLog);
        buildBoard(state.surface);
        renderStats();
        ensureBoardVisibility();
        advanceLevel();
      }

      function advanceLevel() {
        clearAutoTimer();
        if (!state.running) {
          return;
        }
        if (state.levelIndex >= state.levels.length) {
          finishRun();
          return;
        }

        const probability = state.levels[state.levelIndex];
        state.levelStats = {
          probability,
          withSyndrome: 0,
          withoutSyndrome: 0,
          logicalErrors: 0,
          events: [],
        };
        levelLabel.textContent = (state.levelIndex + 1) + ' (p = ' + probability + ')';
        addLog('Level ' + (state.levelIndex + 1) + ' started with p=' + probability + '.');
        state.current = null;
        setStatus('Generating rounds...', false);
        setControlsEnabled(false);
        nextRoundBtn.disabled = true;
        renderStats();
        scheduleNextRound();
      }

      function scheduleNextRound() {
        clearAutoTimer();
        if (!state.running) {
          return;
        }
        const levelStats = state.levelStats;
        if (levelStats.withSyndrome >= targetInteractiveRounds) {
          finishLevel();
          return;
        }

        const probability = levelStats.probability;
        const error = randomVector(state.surface.dataQubits.length, probability);
        const syndrome = state.surface.syndrome(error);
        if (sumVector(syndrome) === 0) {
          levelStats.withoutSyndrome += 1;
          if (state.surface.logicalParity(error) === 1) {
            levelStats.logicalErrors += 1;
            levelStats.events.push({ type: 'no_syndrome_logical_error', round: levelStats.withoutSyndrome });
            addLog('No syndrome observed but logical error detected.');
          } else {
            levelStats.events.push({ type: 'no_syndrome_clear', round: levelStats.withoutSyndrome });
            addLog('No syndrome observed. Skipping to next sample.');
          }
          renderStats();
          setTimeout(scheduleNextRound, 50);
          return;
        }

        const correction = new Array(error.length).fill(0);
        state.current = {
          probability,
          error,
          correction,
          residual: error.slice(),
          syndrome,
        };
        addLog('Round ' + (levelStats.withSyndrome + 1) + ' ready. Syndrome weight ' + sumVector(syndrome) + '.');
        setStatus('Flip qubits to clear the syndrome.', false);
        setControlsEnabled(true);
        nextRoundBtn.disabled = true;
        updateBoardMarkers();
        renderStats();
      }

      function finishLevel() {
        clearAutoTimer();
        const totalRounds = state.levelStats.withSyndrome + state.levelStats.withoutSyndrome;
        state.levelsData.push({
          probability: state.levelStats.probability,
          interactive_rounds: state.levelStats.withSyndrome,
          no_syndrome_rounds: state.levelStats.withoutSyndrome,
          total_rounds: totalRounds,
          logical_failures: state.levelStats.logicalErrors,
          events: state.levelStats.events,
        });
        addLog('Level ' + (state.levelIndex + 1) + ' completed.');
        state.levelIndex += 1;
        renderStats();
        setTimeout(advanceLevel, 200);
      }

      function finishRun() {
        clearAutoTimer();
        state.running = false;
        setControlsEnabled(false);
        nextRoundBtn.disabled = true;
        nextRoundBtn.classList.remove('active');
        nextRoundBtn.style.removeProperty('--progress');
        startBtn.disabled = false;
        if (selectRounds) {
          selectRounds.disabled = false;
        }
        if (selectLevels) {
          selectLevels.disabled = false;
        }
        setStatus('All levels completed. Saving summary.', false);
        addLog('Session complete - preparing summary.');

        const probabilityStats = state.levelsData.map((level) => ({
          probability: level.probability,
          total_rounds: level.total_rounds,
          logical_failures: level.logical_failures,
        }));

        const totals = probabilityStats.reduce((acc, entry) => {
          acc.total_rounds += entry.total_rounds;
          acc.logical_failures += entry.logical_failures;
          return acc;
        }, { total_rounds: 0, logical_failures: 0 });

        const summary = {
          session_id: state.sessionId,
          name: state.playerName,
          grid_size: state.surface ? state.surface.d : null,
          rounds_per_level: targetInteractiveRounds,
          error_probabilities: state.levels,
          probability_stats: probabilityStats,
          totals,
          levels: state.levelsData,
        };

        summaryCard.classList.add('visible');
        summaryOutput.textContent = JSON.stringify(summary, null, 2);

        const payload = {
          uid: state.sessionId,
          name: state.playerName,
          grid_size: summary.grid_size,
          error_probabilities: summary.error_probabilities,
          probability_stats: probabilityStats,
        };

        fetch('/api/game/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status);
            }
            return response.json();
          })
          .then((data) => {
            addLog('Session stored with id ' + data.uid + '.');
            setStatus('Session saved to the database.', false);
          })
          .catch((error) => {
            setStatus('Could not save session: ' + error.message, true);
            addLog('Failed to persist session.');
          });
      }

      function handleContinue() {
        if (!state.current) {
          return;
        }
        clearAutoTimer();
        state.current = null;
        nextRoundBtn.disabled = true;
        setStatus('Preparing next round...', false);
        setControlsEnabled(false);
        setTimeout(scheduleNextRound, 200);
      }

      function showDataOverlay() {
        overlay.classList.add('visible');
        overlayOutput.textContent = 'Loading...';
        fetch('/api/game/data')
          .then((response) => {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status);
            }
            return response.json();
          })
          .then((data) => {
            overlayOutput.textContent = JSON.stringify(data, null, 2);
          })
          .catch((error) => {
            overlayOutput.textContent = 'Failed to load data: ' + error.message;
          });
      }

      function hideOverlay(event) {
        if (!event || event.target === overlay || event.target === overlayClose) {
          overlay.classList.remove('visible');
        }
      }

      function uuid() {
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, function(c) {
          return (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16);
        });
      }

      if (selectRounds) {
        selectRounds.addEventListener('change', handleRoundsChange);
      }
      if (selectLevels) {
        selectLevels.addEventListener('change', handleLevelsChange);
      }
      if (expertToggle) {
        expertToggle.addEventListener('change', () => {
          applyExpertMode(Boolean(expertToggle.checked));
        });
      }
      if (autoAdvanceToggle) {
        autoAdvanceToggle.addEventListener('click', () => {
          const nextEnabled = !state.autoAdvanceEnabled;
          setAutoAdvanceEnabled(nextEnabled);
          addLog(nextEnabled ? 'Auto-advance enabled.' : 'Auto-advance disabled.');
        });
      }

      startBtn.addEventListener('click', startGame);
      resetBtn.addEventListener('click', resetState);
      showStatsBtn.addEventListener('click', showStatsOverlay);
      showDataBtn.addEventListener('click', showDataOverlay);
      nextRoundBtn.addEventListener('click', handleContinue);
      overlay.addEventListener('click', hideOverlay);
      overlayClose.addEventListener('click', hideOverlay);
      statsOverlay.addEventListener('click', hideStatsOverlay);
      statsOverlayClose.addEventListener('click', hideStatsOverlay);
      window.addEventListener('resize', requestBoardScale);

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          overlay.classList.remove('visible');
          if (statsOverlay) {
            statsOverlay.classList.remove('visible');
          }
        }
      });

      clearBoard();
      applyExpertMode(Boolean(expertToggle && expertToggle.checked));
      setAutoAdvanceEnabled(state.autoAdvanceEnabled);
    })();
  </script>
</body>
</html>
