<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Whack-an-Error - Surface Code</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      background: #040712;
      color: #f0f4ff;
      --cell-min-size: 46px;
      --cell-min-height: 46px;
      --cell-gap: 8px;
      --stabilizer-size: 36px;
      --qubit-font-size: 0.95rem;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 32px;
      background: radial-gradient(circle at 15% 20%, rgba(76, 104, 255, 0.24), transparent 55%),
                  radial-gradient(circle at 80% 10%, rgba(255, 120, 180, 0.18), transparent 50%),
                  linear-gradient(145deg, rgba(7, 10, 28, 0.94), rgba(6, 8, 20, 0.96));
    }
    .app-shell {
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(520px, 1fr);
      gap: 28px;
      width: min(1120px, 100%);
    }
    .panel {
      background: rgba(10, 13, 32, 0.88);
      border: 1px solid rgba(118, 138, 255, 0.28);
      border-radius: 20px;
      padding: 28px;
      box-shadow: 0 32px 64px -28px rgba(0, 0, 0, 0.78);
      backdrop-filter: blur(18px);
    }
    h1 {
      margin: 0 0 12px;
      font-size: 1.8rem;
      letter-spacing: 0.02em;
    }
    p.subtitle {
      margin: 0 0 24px;
      opacity: 0.72;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
    }
    .form-field {
      margin-bottom: 18px;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      cursor: pointer;
    }
    .toggle input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: #38bdf8;
    }
    .toggle span {
      font-size: 1rem;
    }
    .toggle-hint {
      margin: 6px 0 0;
      opacity: 0.65;
      font-size: 0.9rem;
    }
    select,
    input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(110, 130, 255, 0.4);
      background: rgba(14, 18, 44, 0.9);
      color: inherit;
      font-size: 1rem;
      box-sizing: border-box;
    }
    body:not(.expert-mode) .expert-only {
      display: none !important;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 22px 0 10px;
    }
    button {
      border: none;
      border-radius: 14px;
      padding: 14px 18px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 140ms ease, box-shadow 140ms ease;
    }
    button.primary {
      background: linear-gradient(135deg, #7dd3fc, #38bdf8);
      color: #04111c;
      flex: 1 1 160px;
    }
    button.secondary {
      background: linear-gradient(135deg, #fbcfe8, #f472b6);
      color: #290917;
      flex: 1 1 160px;
    }
    button.ghost {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(205, 215, 255, 0.25);
      color: inherit;
      flex: 1 1 140px;
    }
    button:disabled {
      opacity: 0.6;
      cursor: wait;
      transform: none;
      box-shadow: none;
    }
    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 24px -16px rgba(150, 200, 255, 0.8);
    }
    .meta-label {
      margin-top: 12px;
      font-size: 0.9rem;
      opacity: 0.65;
    }
    .stats {
      margin-top: 24px;
      display: grid;
      gap: 8px;
    }
    .stats div {
      background: rgba(20, 24, 56, 0.7);
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px solid rgba(100, 120, 255, 0.24);
      font-size: 0.95rem;
    }
    .log {
      margin-top: 24px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 6px;
    }
    .log h2 {
      margin-top: 0;
      font-size: 1.05rem;
    }
    .log ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 8px;
      font-size: 0.9rem;
    }
    .log li {
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(18, 22, 50, 0.74);
      border: 1px solid rgba(114, 132, 255, 0.2);
    }
    .game-surface {
      display: grid;
      gap: 20px;
    }
    .board-wrapper {
      background: rgba(8, 10, 26, 0.85);
      border-radius: 22px;
      padding: 26px;
      border: 1px solid rgba(135, 156, 255, 0.24);
      backdrop-filter: blur(10px);
      scroll-margin-top: 18px;
    }
    .board-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 18px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .board {
      display: grid;
      gap: var(--cell-gap);
      --board-size: 1;
      grid-template-columns: repeat(var(--board-size), minmax(var(--cell-min-size), 1fr));
      justify-items: stretch;
    }
    .cell {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: var(--cell-min-height);
    }
    .cell.placeholder {
      color: rgba(220, 224, 255, 0.5);
      font-size: 0.95rem;
      padding: 16px;
      text-align: center;
    }
    .cell::after {
      content: "";
      position: absolute;
      inset: 6px;
      border-radius: 12px;
      background: rgba(18, 22, 50, 0.45);
      border: 1px dashed rgba(97, 117, 255, 0.22);
      opacity: 0.35;
    }
    .cell.empty::after {
      display: none;
    }
    .qubit {
      position: relative;
      z-index: 2;
      width: 100%;
      height: 100%;
      border-radius: 14px;
      border: 2px solid transparent;
      background: linear-gradient(135deg, rgba(83, 109, 254, 0.9), rgba(48, 79, 216, 0.9));
      color: #f6f7ff;
      font-weight: 600;
      font-size: var(--qubit-font-size);
      cursor: pointer;
      transition: transform 120ms ease, border 120ms ease, box-shadow 120ms ease;
    }
    .qubit:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 14px 28px -16px rgba(102, 153, 255, 0.8);
    }
    .qubit.has-error {
      border-color: rgba(242, 94, 139, 0.95);
      background: linear-gradient(135deg, rgba(242, 94, 139, 0.85), rgba(200, 76, 188, 0.85));
    }
    .qubit.corrected {
      box-shadow: inset 0 0 0 2px rgba(115, 255, 202, 0.9);
    }
    .qubit.residual {
      border-color: rgba(255, 189, 99, 0.9);
    }
    .qubit.edge {
      border-style: dashed;
    }
    .qubit:disabled {
      cursor: default;
      opacity: 0.75;
    }
    .stabilizer {
      position: relative;
      z-index: 1;
      width: var(--stabilizer-size);
      height: var(--stabilizer-size);
      border-radius: 999px;
      background: rgba(93, 116, 255, 0.42);
      border: 2px solid rgba(94, 112, 255, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: 600;
      color: rgba(220, 229, 255, 0.78);
      transition: transform 160ms ease, background 160ms ease, border 160ms ease;
    }
    .stabilizer.active {
      background: rgba(255, 125, 163, 0.88);
      border-color: rgba(255, 149, 201, 0.8);
      color: #2f0712;
      transform: scale(1.05);
      box-shadow: 0 0 0 8px rgba(255, 130, 180, 0.1);
    }
    @media (max-width: 720px) {
      :root {
        --cell-min-size: 36px;
        --cell-min-height: 36px;
        --cell-gap: 8px;
        --stabilizer-size: 30px;
        --qubit-font-size: 0.82rem;
      }
      .board-wrapper {
        padding: 20px;
      }
      .log {
        max-height: 200px;
      }
    }
    @media (max-width: 540px) {
      :root {
        --cell-min-size: 28px;
        --cell-min-height: 28px;
        --cell-gap: 4px;
        --stabilizer-size: 24px;
        --qubit-font-size: 0.72rem;
      }
      .board-wrapper {
        padding: 16px;
      }
      .actions {
        gap: 10px;
      }
      .log {
        max-height: 180px;
      }
    }
    @media (max-width: 420px) {
      :root {
        --cell-min-size: 20px;
        --cell-min-height: 20px;
        --cell-gap: 2px;
        --stabilizer-size: 18px;
        --qubit-font-size: 0.62rem;
      }
      body {
        padding: 14px;
      }
      .board-wrapper {
        padding: 14px;
      }
    }
    .status-line {
      margin: 6px 0 0;
      min-height: 1.4em;
      font-size: 0.98rem;
    }
    .status-line.error {
      color: #f8989a;
    }
    .summary-card {
      margin-top: 18px;
      padding: 18px;
      border-radius: 16px;
      background: rgba(18, 26, 56, 0.8);
      border: 1px solid rgba(118, 140, 255, 0.24);
      display: none;
    }
    .summary-card.visible {
      display: block;
    }
    .summary-card pre {
      margin-top: 12px;
      max-height: 220px;
      overflow: auto;
      background: rgba(6, 10, 34, 0.72);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(90, 110, 255, 0.22);
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(4, 6, 16, 0.78);
      z-index: 20;
      padding: 24px;
    }
    .overlay.visible {
      display: flex;
    }
    .overlay-card {
      background: rgba(10, 14, 30, 0.95);
      padding: 28px;
      border-radius: 18px;
      width: min(720px, 100%);
      max-height: 82vh;
      overflow: auto;
      border: 1px solid rgba(132, 150, 255, 0.28);
      position: relative;
      box-shadow: 0 28px 56px -32px rgba(0, 0, 0, 0.8);
    }
    .overlay-card pre {
      background: rgba(12, 16, 40, 0.88);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(94, 122, 255, 0.2);
      max-height: 60vh;
      overflow: auto;
    }
    .overlay-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: none;
      background: rgba(255, 255, 255, 0.18);
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
    }
    @media (max-width: 960px) {
      body {
        padding: 18px;
      }
      .app-shell {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <aside class="panel">
      <h1>Whack-an-Error</h1>
      <p class="subtitle">Explore the surface-code correction loop. Flip qubits to clear the syndrome without inducing a logical error.</p>

      <div class="form-field">
        <label class="toggle" for="expert-toggle">
          <input type="checkbox" id="expert-toggle" />
          <span>Expert mode</span>
        </label>
        <p class="toggle-hint">Reveal advanced controls and diagnostics.</p>
      </div>

      <div class="form-field expert-only">
        <label for="player-name">Your name</label>
        <input id="player-name" type="text" placeholder="Optional" maxlength="100" data-expert-control="true" />
      </div>

      <div class="form-field">
        <label for="config-d">Code distance (d)</label>
        <select id="config-d" aria-label="Select code distance">
          {% for value in grid_sizes %}
          <option value="{{ value }}">d = {{ value }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="form-field expert-only">
        <label for="config-levels">Levels per run</label>
        <select id="config-levels" aria-label="Select number of levels" data-expert-control="true">
          {% for value in allowed_level_counts %}
          <option value="{{ value }}" {% if value == level_count %}selected{% endif %}>{{ value }} levels</option>
          {% endfor %}
        </select>
      </div>

      <div class="actions">
        <button type="button" class="primary" id="start-game">Start Game</button>
        <button type="button" class="secondary expert-only" id="show-data">Show Data</button>
        <button type="button" class="ghost" id="reset-game">Reset</button>
      </div>

      <div class="form-field expert-only">
        <label for="config-rounds">Interactive rounds per level</label>
        <select id="config-rounds" aria-label="Select rounds per level" data-expert-control="true">
          {% for value in allowed_rounds %}
          <option value="{{ value }}" {% if value == rounds_per_level %}selected{% endif %}>{{ value }} rounds</option>
          {% endfor %}
        </select>
      </div>

      <p class="meta-label">Database: {{ database_mode }}</p>

      <div class="stats">
        <div><strong>Level:</strong> <span id="stat-level">-</span></div>
        <div><strong>Interactive rounds:</strong> <span id="stat-round">-</span></div>
        <div><strong>Logical errors:</strong> <span id="stat-logical">-</span></div>
        <div><strong>No syndrome rounds:</strong> <span id="stat-nosyndrome">-</span></div>
      </div>

      <div class="log expert-only">
        <h2>Event log</h2>
        <ul id="log-list"></ul>
      </div>
    </aside>

    <main class="panel game-surface">
      <div class="board-wrapper">
        <div class="board-meta">
          <div><strong>Current level:</strong> <span id="level-label">-</span></div>
          <div><strong>Target interactive rounds:</strong> <span id="target-rounds">{{ rounds_per_level }}</span></div>
        </div>
        <div class="board" id="board" aria-live="polite"></div>
        <p class="status-line" id="status-line" role="status" aria-live="polite"></p>
        <div class="actions" style="margin-top: 18px;">
          <button type="button" class="primary" id="next-round" disabled>Continue</button>
        </div>
      </div>

      <section class="summary-card" id="summary-card">
        <h2>Session summary</h2>
        <p>Final statistics for this run. They are stored in the database.</p>
        <pre id="summary-output">No data yet.</pre>
      </section>
    </main>
  </div>

  <div class="overlay" id="data-overlay" role="dialog" aria-modal="true" aria-labelledby="overlay-title">
    <div class="overlay-card">
      <button class="overlay-close" id="overlay-close" aria-label="Close">x</button>
      <h2 id="overlay-title">Stored game runs</h2>
      <pre id="overlay-output">Loading...</pre>
    </div>
  </div>

  <script id="config-data" type="application/json">
    {{ {
      "grid_sizes": grid_sizes,
      "levels": levels,
      "level_count": level_count,
      "allowed_level_counts": allowed_level_counts,
      "level_bounds": level_bounds,
      "level_precision": level_precision,
      "rounds_per_level": rounds_per_level,
      "allowed_rounds": allowed_rounds
    } | tojson }}
  </script>

  <script>
    (function() {
      const config = JSON.parse(document.getElementById('config-data').textContent);
      const allowedSizes = Array.isArray(config.grid_sizes) ? config.grid_sizes : [];
      const defaultLevels = Array.isArray(config.levels) ? config.levels : [];
      const boundsArray = Array.isArray(config.level_bounds) ? config.level_bounds : [];
      const minProbability = Number(boundsArray[0]);
      const maxProbability = Number(boundsArray[1]);
      const precisionValue = Number(config.level_precision);
      const levelPrecision = Number.isInteger(precisionValue) && precisionValue >= 0 ? precisionValue : 3;
      const allowedLevelCounts = (config.allowed_level_counts || [])
        .map((value) => Number(value))
        .filter((value) => Number.isFinite(value) && value > 0)
        .sort((a, b) => a - b);
      const rawLevelCount = Number(config.level_count);

      function generateLevels(count) {
        const min = Number.isFinite(minProbability) ? minProbability : 0.01;
        const max = Number.isFinite(maxProbability) ? maxProbability : min;
        const precision = levelPrecision;
        const safeCount = Math.max(1, Math.floor(Number(count) || 0));
        if (safeCount === 1 || max === min) {
          return [Number(min.toFixed(precision))];
        }
        const step = (max - min) / (safeCount - 1);
        const levels = [];
        for (let i = 0; i < safeCount; i += 1) {
          const value = min + step * i;
          levels.push(Number(value.toFixed(precision)));
        }
        return levels;
      }

      let selectedLevelCount = Number.isFinite(rawLevelCount) ? Math.max(1, Math.floor(rawLevelCount)) : (defaultLevels.length || 3);
      if (allowedLevelCounts.length && !allowedLevelCounts.includes(selectedLevelCount)) {
        selectedLevelCount = allowedLevelCounts[0];
      } else if (!allowedLevelCounts.length && selectedLevelCount < 1) {
        selectedLevelCount = 1;
      }

      const baseLevelCount = selectedLevelCount;

      let initialLevels = defaultLevels.slice();
      if (initialLevels.length !== selectedLevelCount) {
        initialLevels = generateLevels(selectedLevelCount);
      }

      const allowedRoundOptions = (config.allowed_rounds || []).map((value) => Number(value));
      let targetInteractiveRounds = Number(config.rounds_per_level);
      if (!Number.isFinite(targetInteractiveRounds) || !allowedRoundOptions.includes(targetInteractiveRounds)) {
        targetInteractiveRounds = allowedRoundOptions.length ? allowedRoundOptions[0] : 3;
      }

      const baseRoundsPerLevel = targetInteractiveRounds;

      const startBtn = document.getElementById('start-game');
      const resetBtn = document.getElementById('reset-game');
      const showDataBtn = document.getElementById('show-data');
      const nextRoundBtn = document.getElementById('next-round');
      const expertToggle = document.getElementById('expert-toggle');
      const selectD = document.getElementById('config-d');
      const selectRounds = document.getElementById('config-rounds');
      const selectLevels = document.getElementById('config-levels');
      const playerNameInput = document.getElementById('player-name');
      const boardWrapper = document.querySelector('.board-wrapper');
      const boardEl = document.getElementById('board');
      const statusLine = document.getElementById('status-line');
      const levelLabel = document.getElementById('level-label');
      const targetRoundsLabel = document.getElementById('target-rounds');
      const summaryCard = document.getElementById('summary-card');
      const summaryOutput = document.getElementById('summary-output');
      const overlay = document.getElementById('data-overlay');
      const overlayOutput = document.getElementById('overlay-output');
      const overlayClose = document.getElementById('overlay-close');
      const logList = document.getElementById('log-list');
      const statLevel = document.getElementById('stat-level');
      const statRound = document.getElementById('stat-round');
      const statLogical = document.getElementById('stat-logical');
      const statNoSyndrome = document.getElementById('stat-nosyndrome');
      const expertControls = document.querySelectorAll('[data-expert-control]');

      if (selectRounds) {
        selectRounds.value = String(targetInteractiveRounds);
      }
      if (selectLevels) {
        selectLevels.value = String(selectedLevelCount);
      }

      const state = {
        running: false,
        surface: null,
        qubitButtons: [],
        stabilizerWidgets: [],
        sessionId: null,
        playerName: null,
        expertMode: Boolean(expertToggle && expertToggle.checked),
        levelIndex: 0,
        levels: initialLevels.slice(),
        levelCount: selectedLevelCount,
        levelStats: null,
        levelsData: [],
        current: null,
      };

      function setStatus(message, isError) {
        statusLine.textContent = message || '';
        statusLine.classList.toggle('error', Boolean(isError));
      }

      function addLog(message) {
        const entry = document.createElement('li');
        entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
        logList.prepend(entry);
        while (logList.children.length > 40) {
          logList.removeChild(logList.lastChild);
        }
      }

      function setExpertControlsDisabled(disabled) {
        expertControls.forEach((element) => {
          if (!element) {
            return;
          }
          element.disabled = disabled;
        });
      }

      function applyExpertMode(isExpert) {
        state.expertMode = isExpert;
        document.body.classList.toggle('expert-mode', isExpert);
        setExpertControlsDisabled(!isExpert);
        if (!isExpert) {
          if (playerNameInput) {
            playerNameInput.value = '';
          }
          if (!state.running) {
            selectedLevelCount = baseLevelCount;
            state.levelCount = baseLevelCount;
            state.levels = generateLevels(baseLevelCount);
            if (selectLevels) {
              selectLevels.value = String(baseLevelCount);
            }
            targetInteractiveRounds = baseRoundsPerLevel;
            if (selectRounds) {
              selectRounds.value = String(targetInteractiveRounds);
            }
          }
        } else if (selectLevels) {
          selectLevels.value = String(selectedLevelCount);
        }
        renderStats();
      }

      function ensureBoardVisibility() {
        if (!boardWrapper) {
          return;
        }
        const compactLayout = window.matchMedia('(max-width: 960px)').matches;
        if (!compactLayout) {
          return;
        }
        const scrollToBoard = () => {
          boardWrapper.scrollIntoView({ block: 'start', behavior: 'smooth' });
        };
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(() => {
            window.setTimeout(scrollToBoard, 60);
          });
        } else {
          window.setTimeout(scrollToBoard, 60);
        }
      }

      function clearBoard() {
        boardEl.textContent = '';
        boardEl.style.setProperty('--board-size', 1);
        const placeholder = document.createElement('div');
        placeholder.className = 'cell placeholder';
        placeholder.textContent = 'Select a distance and press Start Game.';
        boardEl.appendChild(placeholder);
        state.qubitButtons = [];
        state.stabilizerWidgets = [];
      }

      class SurfaceCode {
        constructor(distance) {
          this.d = distance;
          this.dataQubits = [];
          this.stabilizers = [];
          this.matrixH = [];
          this.logicalVector = [];
          this.build();
        }

        build() {
          const d = this.d;
          let idx = 0;
          for (let row = 0; row < d; row += 1) {
            for (let col = 0; col < d; col += 1) {
              this.dataQubits.push({ idx: idx++, row, col, isEdge: col === 0 });
            }
          }
          for (let row = 0; row < d - 1; row += 1) {
            for (let col = 0; col < d - 1; col += 1) {
              this.dataQubits.push({ idx: idx++, row: row + 0.5, col: col + 0.5, isEdge: false });
            }
          }

          const neighborsFor = (row, col) => {
            const close = (a, b) => Math.abs(a - b) < 1e-6;
            return this.dataQubits
              .filter((q) =>
                (close(q.row, row - 0.5) && close(q.col, col)) ||
                (close(q.row, row + 0.5) && close(q.col, col)) ||
                (close(q.row, row) && close(q.col, col - 0.5)) ||
                (close(q.row, row) && close(q.col, col + 0.5)))
              .map((q) => q.idx);
          };

          let sIdx = 0;
          for (let row = 0; row < d; row += 1) {
            for (let col = 0; col < d - 1; col += 1) {
              const colMid = col + 0.5;
              const neighborList = neighborsFor(row, colMid);
              this.stabilizers.push({ idx: sIdx, row, col: colMid, neighbors: neighborList });
              this.matrixH.push(neighborList);
              sIdx += 1;
            }
          }

          this.logicalVector = this.dataQubits.map((q) => (q.col === 0 ? 1 : 0));
        }

        syndrome(vector) {
          return this.matrixH.map((indices) => {
            let total = 0;
            for (const idx of indices) {
              total ^= vector[idx];
            }
            return total;
          });
        }

        logicalParity(vector) {
          let total = 0;
          for (let i = 0; i < vector.length; i += 1) {
            if (this.logicalVector[i]) {
              total ^= vector[i];
            }
          }
          return total;
        }
      }

      function buildBoard(surface) {
        boardEl.textContent = '';
        const size = surface.d * 2 - 1;
        boardEl.style.setProperty('--board-size', size);
        const cells = Array.from({ length: size * size }, () => {
          const wrapper = document.createElement('div');
          wrapper.className = 'cell empty';
          boardEl.appendChild(wrapper);
          return wrapper;
        });

        const indexFor = (row, col) => row * size + col;

        state.qubitButtons = surface.dataQubits.map((q) => {
          const r = Math.round(q.row * 2);
          const c = Math.round(q.col * 2);
          const button = document.createElement('button');
          button.className = 'qubit';
          button.type = 'button';
          button.textContent = String(q.idx);
          if (q.isEdge) {
            button.classList.add('edge');
          }
          button.dataset.idx = String(q.idx);
          button.disabled = true;
          button.addEventListener('click', () => handleQubitFlip(q.idx));
          const cell = cells[indexFor(r, c)];
          cell.classList.remove('empty');
          cell.appendChild(button);
          return button;
        });

        state.stabilizerWidgets = surface.stabilizers.map((s) => {
          const r = Math.round(s.row * 2);
          const c = Math.round(s.col * 2);
          const span = document.createElement('div');
          span.className = 'stabilizer';
          span.textContent = String(s.idx);
          const cell = cells[indexFor(r, c)];
          cell.classList.remove('empty');
          cell.appendChild(span);
          return span;
        });
      }

      function updateBoardMarkers() {
        if (!state.current) {
          return;
        }
        const { error, correction, residual, syndrome } = state.current;
        const showErrors = sumVector(syndrome) === 0;

        state.qubitButtons.forEach((btn, idx) => {
          const hasInitialError = showErrors && Boolean(error[idx]);
          btn.classList.toggle('has-error', hasInitialError);
          btn.classList.toggle('corrected', Boolean(correction[idx]));
          btn.classList.toggle('residual', showErrors && Boolean(residual[idx]));
        });

        state.stabilizerWidgets.forEach((widget, idx) => {
          widget.classList.toggle('active', Boolean(syndrome[idx]));
        });
      }

      function setControlsEnabled(enabled) {
        state.qubitButtons.forEach((btn) => {
          btn.disabled = !enabled;
        });
      }

      function randomVector(length, probability) {
        const vector = new Array(length);
        for (let i = 0; i < length; i += 1) {
          vector[i] = Math.random() < probability ? 1 : 0;
        }
        return vector;
      }

      function sumVector(vector) {
        return vector.reduce((total, value) => total + value, 0);
      }

      function handleQubitFlip(idx) {
        if (!state.running || !state.current) {
          return;
        }
        const current = state.current;
        current.correction[idx] ^= 1;
        current.residual[idx] = current.error[idx] ^ current.correction[idx];
        current.syndrome = state.surface.syndrome(current.residual);
        updateBoardMarkers();

        const weight = sumVector(current.syndrome);
        if (weight === 0) {
          setControlsEnabled(false);
          nextRoundBtn.disabled = false;
          const levelStats = state.levelStats;
          levelStats.withSyndrome += 1;
          if (state.surface.logicalParity(current.residual) === 1) {
            levelStats.logicalErrors += 1;
            levelStats.events.push({ type: 'logical_error', round: levelStats.withSyndrome });
            setStatus('Logical error detected. Continue to the next round.', true);
            addLog('Logical error recorded for this level.');
          } else {
            levelStats.events.push({ type: 'success', round: levelStats.withSyndrome });
            setStatus('Syndrome cleared. No logical error.', false);
            addLog('Syndrome cleared without logical error.');
          }
          renderStats();
          if (levelStats.withSyndrome >= targetInteractiveRounds) {
            addLog('Target number of interactive rounds reached for this level.');
          }
        } else {
          setStatus('Syndrome weight ' + weight + '. Continue correcting.');
        }
      }

      function renderStats() {
        if (state.running && state.levelStats) {
          statLevel.textContent = (state.levelIndex + 1) + ' / ' + state.levels.length;
          statRound.textContent = state.levelStats.withSyndrome + '/' + targetInteractiveRounds;
          statLogical.textContent = String(state.levelStats.logicalErrors);
          statNoSyndrome.textContent = String(state.levelStats.withoutSyndrome);
        } else {
          statLevel.textContent = '-';
          statRound.textContent = '-';
          statLogical.textContent = '-';
          statNoSyndrome.textContent = '-';
        }
        targetRoundsLabel.textContent = String(targetInteractiveRounds);
        if (selectRounds && selectRounds.value !== String(targetInteractiveRounds)) {
          selectRounds.value = String(targetInteractiveRounds);
        }
        if (selectLevels && selectLevels.value !== String(selectedLevelCount)) {
          selectLevels.value = String(selectedLevelCount);
        }
      }

      function handleRoundsChange() {
        if (!selectRounds) {
          return;
        }
        if (!state.expertMode) {
          selectRounds.value = String(targetInteractiveRounds);
          return;
        }
        const chosen = Number.parseInt(selectRounds.value, 10);
        if (!Number.isFinite(chosen) || !allowedRoundOptions.includes(chosen)) {
          return;
        }
        if (targetInteractiveRounds === chosen) {
          return;
        }
        targetInteractiveRounds = chosen;
        addLog('Rounds per level set to ' + chosen + '.');
        renderStats();
      }

      function handleLevelsChange() {
        if (!selectLevels) {
          return;
        }
        if (!state.expertMode) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        const chosen = Number.parseInt(selectLevels.value, 10);
        if (!Number.isFinite(chosen)) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        const normalized = Math.max(1, Math.floor(chosen));
        if (allowedLevelCounts.length && !allowedLevelCounts.includes(normalized)) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        if (state.running) {
          selectLevels.value = String(selectedLevelCount);
          return;
        }
        if (selectedLevelCount === normalized) {
          return;
        }
        selectedLevelCount = normalized;
        state.levelCount = normalized;
        state.levels = generateLevels(normalized);
        addLog('Levels per run set to ' + normalized + '.');
        renderStats();
      }

      function resetState() {
        state.running = false;
        state.surface = null;
        state.qubitButtons = [];
        state.stabilizerWidgets = [];
        state.sessionId = null;
        state.playerName = null;
        state.levelIndex = 0;
        state.levelCount = selectedLevelCount;
        state.levels = generateLevels(selectedLevelCount);
        state.levelStats = null;
        state.levelsData = [];
        state.current = null;
        nextRoundBtn.disabled = true;
        summaryCard.classList.remove('visible');
        summaryOutput.textContent = 'No data yet.';
        levelLabel.textContent = '-';
        setStatus('', false);
        clearBoard();
        startBtn.disabled = false;
        if (expertToggle) {
          applyExpertMode(Boolean(expertToggle.checked));
        } else {
          renderStats();
        }
      }

      function startGame() {
        const distance = Number.parseInt(selectD.value, 10);
        if (!allowedSizes.includes(distance)) {
          setStatus('Unknown code distance selected.', true);
          return;
        }
        const isExpert = Boolean(expertToggle && expertToggle.checked);
        let playerName = '';
        if (isExpert && playerNameInput) {
          playerName = playerNameInput.value.trim();
        }
        if (isExpert && selectRounds) {
          const selectedRounds = Number.parseInt(selectRounds.value, 10);
          if (Number.isFinite(selectedRounds) && allowedRoundOptions.includes(selectedRounds)) {
            targetInteractiveRounds = selectedRounds;
          }
        }
        if (isExpert && selectLevels) {
          const selectedLevels = Number.parseInt(selectLevels.value, 10);
          if (Number.isFinite(selectedLevels)) {
            const normalized = Math.max(1, Math.floor(selectedLevels));
            if (!allowedLevelCounts.length || allowedLevelCounts.includes(normalized)) {
              selectedLevelCount = normalized;
            }
          }
        }
        resetState();
        state.playerName = state.expertMode && playerName ? playerName : null;
        state.running = true;
        state.surface = new SurfaceCode(distance);
        state.sessionId = uuid();
        startBtn.disabled = true;
        if (state.expertMode && selectRounds) {
          selectRounds.disabled = true;
        }
        if (state.expertMode && selectLevels) {
          selectLevels.disabled = true;
        }
        if (selectLevels) {
          selectLevels.value = String(selectedLevelCount);
        }
        const sessionLog = 'New session ' + state.sessionId + ' started with d=' + distance + (state.playerName ? ' for ' + state.playerName : '') + '.';
        addLog(sessionLog);
        buildBoard(state.surface);
        renderStats();
        ensureBoardVisibility();
        advanceLevel();
      }

      function advanceLevel() {
        if (!state.running) {
          return;
        }
        if (state.levelIndex >= state.levels.length) {
          finishRun();
          return;
        }

        const probability = state.levels[state.levelIndex];
        state.levelStats = {
          probability,
          withSyndrome: 0,
          withoutSyndrome: 0,
          logicalErrors: 0,
          events: [],
        };
        levelLabel.textContent = (state.levelIndex + 1) + ' - p = ' + probability;
        addLog('Level ' + (state.levelIndex + 1) + ' started with p=' + probability + '.');
        state.current = null;
        setStatus('Generating rounds...', false);
        setControlsEnabled(false);
        nextRoundBtn.disabled = true;
        renderStats();
        scheduleNextRound();
      }

      function scheduleNextRound() {
        if (!state.running) {
          return;
        }
        const levelStats = state.levelStats;
        if (levelStats.withSyndrome >= targetInteractiveRounds) {
          finishLevel();
          return;
        }

        const probability = levelStats.probability;
        const error = randomVector(state.surface.dataQubits.length, probability);
        const syndrome = state.surface.syndrome(error);
        if (sumVector(syndrome) === 0) {
          levelStats.withoutSyndrome += 1;
          if (state.surface.logicalParity(error) === 1) {
            levelStats.logicalErrors += 1;
            levelStats.events.push({ type: 'no_syndrome_logical_error', round: levelStats.withoutSyndrome });
            addLog('No syndrome observed but logical error detected.');
          } else {
            levelStats.events.push({ type: 'no_syndrome_clear', round: levelStats.withoutSyndrome });
            addLog('No syndrome observed. Skipping to next sample.');
          }
          renderStats();
          setTimeout(scheduleNextRound, 50);
          return;
        }

        const correction = new Array(error.length).fill(0);
        state.current = {
          probability,
          error,
          correction,
          residual: error.slice(),
          syndrome,
        };
        addLog('Interactive round ' + (levelStats.withSyndrome + 1) + ' ready. Syndrome weight ' + sumVector(syndrome) + '.');
        setStatus('Flip qubits to clear the syndrome.', false);
        setControlsEnabled(true);
        nextRoundBtn.disabled = true;
        updateBoardMarkers();
        renderStats();
      }

      function finishLevel() {
        const totalRounds = state.levelStats.withSyndrome + state.levelStats.withoutSyndrome;
        state.levelsData.push({
          probability: state.levelStats.probability,
          interactive_rounds: state.levelStats.withSyndrome,
          no_syndrome_rounds: state.levelStats.withoutSyndrome,
          total_rounds: totalRounds,
          logical_failures: state.levelStats.logicalErrors,
          events: state.levelStats.events,
        });
        addLog('Level ' + (state.levelIndex + 1) + ' completed.');
        state.levelIndex += 1;
        renderStats();
        setTimeout(advanceLevel, 200);
      }

      function finishRun() {
        state.running = false;
        setControlsEnabled(false);
        nextRoundBtn.disabled = true;
        startBtn.disabled = false;
        if (selectRounds) {
          selectRounds.disabled = false;
        }
        if (selectLevels) {
          selectLevels.disabled = false;
        }
        setStatus('All levels completed. Saving summary.', false);
        addLog('Session complete - preparing summary.');

        const probabilityStats = state.levelsData.map((level) => ({
          probability: level.probability,
          total_rounds: level.total_rounds,
          logical_failures: level.logical_failures,
        }));

        const totals = probabilityStats.reduce((acc, entry) => {
          acc.total_rounds += entry.total_rounds;
          acc.logical_failures += entry.logical_failures;
          return acc;
        }, { total_rounds: 0, logical_failures: 0 });

        const summary = {
          session_id: state.sessionId,
          name: state.playerName,
          grid_size: state.surface ? state.surface.d : null,
          rounds_per_level: targetInteractiveRounds,
          error_probabilities: state.levels,
          probability_stats: probabilityStats,
          totals,
          levels: state.levelsData,
        };

        summaryCard.classList.add('visible');
        summaryOutput.textContent = JSON.stringify(summary, null, 2);

        const payload = {
          uid: state.sessionId,
          name: state.playerName,
          grid_size: summary.grid_size,
          error_probabilities: summary.error_probabilities,
          probability_stats: probabilityStats,
        };

        fetch('/api/game/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status);
            }
            return response.json();
          })
          .then((data) => {
            addLog('Session stored with id ' + data.uid + '.');
            setStatus('Session saved to the database.', false);
          })
          .catch((error) => {
            setStatus('Could not save session: ' + error.message, true);
            addLog('Failed to persist session.');
          });
      }

      function handleContinue() {
        if (!state.current) {
          return;
        }
        state.current = null;
        nextRoundBtn.disabled = true;
        setStatus('Preparing next round...', false);
        setControlsEnabled(false);
        setTimeout(scheduleNextRound, 200);
      }

      function showDataOverlay() {
        overlay.classList.add('visible');
        overlayOutput.textContent = 'Loading...';
        fetch('/api/game/data')
          .then((response) => {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status);
            }
            return response.json();
          })
          .then((data) => {
            overlayOutput.textContent = JSON.stringify(data, null, 2);
          })
          .catch((error) => {
            overlayOutput.textContent = 'Failed to load data: ' + error.message;
          });
      }

      function hideOverlay(event) {
        if (!event || event.target === overlay || event.target === overlayClose) {
          overlay.classList.remove('visible');
        }
      }

      function uuid() {
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, function(c) {
          return (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16);
        });
      }

      if (selectRounds) {
        selectRounds.addEventListener('change', handleRoundsChange);
      }
      if (selectLevels) {
        selectLevels.addEventListener('change', handleLevelsChange);
      }
      if (expertToggle) {
        expertToggle.addEventListener('change', () => {
          applyExpertMode(Boolean(expertToggle.checked));
        });
      }

      startBtn.addEventListener('click', startGame);
      resetBtn.addEventListener('click', resetState);
      showDataBtn.addEventListener('click', showDataOverlay);
      nextRoundBtn.addEventListener('click', handleContinue);
      overlay.addEventListener('click', hideOverlay);
      overlayClose.addEventListener('click', hideOverlay);

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          overlay.classList.remove('visible');
        }
      });

      clearBoard();
      applyExpertMode(Boolean(expertToggle && expertToggle.checked));
    })();
  </script>
</body>
</html>
